/*
 * generated by Xtext 2.17.1
 */
package com.faug.mvc.js.ui.internal;

import static io.undertow.Handlers.resource;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.net.Socket;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.Deque;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl;
import org.eclipse.ui.IWorkbenchPartSite;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.browser.IWebBrowser;
import org.eclipse.ui.internal.PartSite;
import org.eclipse.ui.internal.browser.InternalBrowserInstance;
import org.eclipse.ui.internal.browser.WebBrowserEditor;
import org.eclipse.ui.part.WorkbenchPart;
import org.eclipse.ui.plugin.AbstractUIPlugin;
import org.eclipse.xtext.ui.shared.SharedStateModule;
import org.eclipse.xtext.util.Modules2;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;

import com.faug.mvc.js.FaugRuntimeModule;
import com.faug.mvc.js.ui.FaugJsPreferences;
import com.faug.mvc.js.ui.FaugUiModule;
import com.faug.mvc.js.ui.JsonUiIHyperlinkDetector;
import com.faug.mvc.js.ui.JsonUiIXtextEditorCallback;
import com.faug.mvc.js.ui.JsonUiIXtextEditorCallback.FaugjsConfigContext;
import com.google.common.collect.Maps;
import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.Injector;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.ReadContext;

import io.undertow.Handlers;
import io.undertow.Undertow;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.server.handlers.resource.PathResourceManager;
import io.undertow.util.FileUtils;
import io.undertow.util.Headers;

/**
 * This class was generated. Customizations should only happen in a newly
 * introduced subclass.
 */
@SuppressWarnings("restriction")
public class JsActivator extends AbstractUIPlugin {

	public static final String PLUGIN_ID = "com.faug.mvc.js.ui";
	public static final String COM_FAUG_MVC_JS_FAUG = "com.faug.mvc.js.Faug";

	private static JsActivator INSTANCE;

	private Map<String, Injector> injectors = Collections
			.synchronizedMap(Maps.<String, Injector>newHashMapWithExpectedSize(1));

	private static Thread server = null;
	private static Undertow us = null;
	
	@Inject
	FaugJsPreferences faugJsPreferences;

	public static void info(String msg) {
		INSTANCE.getLog().log(new Status(Status.INFO, PLUGIN_ID, Status.OK, msg, null));
	}
	
	public static void error(String msg, Throwable e) {
		INSTANCE.getLog().log(new Status(Status.ERROR, PLUGIN_ID, Status.WARNING, msg, e));
	}
	
	static class AceApiPushHandler implements HttpHandler {
		@Override
		public void handleRequest(HttpServerExchange exchange) throws Exception {
			if (exchange.isInIoThread()) {
		      exchange.dispatch(this);
		      return;
		    }
			String action = Optional.ofNullable(exchange.getQueryParameters().get("action")).map(Deque::getFirst).orElse("save");
			switch (action) {
			case "save":
				String bid = Optional.ofNullable(exchange.getQueryParameters().get("bid")).map(Deque::getFirst).orElse(null);
				long modt = Long.valueOf(Optional.ofNullable(exchange.getQueryParameters().get("modt")).map(Deque::getFirst).orElse("-1"));
				exchange.startBlocking();
				String inp = FileUtils.readFile(exchange.getInputStream());
				ReadContext rc = JsonPath.parse(inp);
				String file = rc.read("$.file");
				String contents = rc.read("$.contents");
				info("SAVE requested for file " + file);
				if(file!=null && contents!=null) {
					long fcmodt = new File(file).lastModified();
					if(modt!=fcmodt) {
						exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
						exchange.getResponseSender().send("{\"status\": false, \"reload\": true}");
						info("SAVE skipped (FILE_CHANGED_ON_FILESYSTEM) for file " + file);
						return;
					}
					BufferedWriter bw = new BufferedWriter(new FileWriter(file));
					bw.write(contents);
					bw.close();
					exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
					exchange.getResponseSender().send("{\"status\": true, \"modt\": "+new File(file).lastModified()+"}");
					info("SAVE was successful for file " + file);
					IWebBrowser wb = JsonUiIHyperlinkDetector.getBrowser(bid);
					makeBrowserDirtyOrClean(wb, false);
					return;
				}
				exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
				exchange.getResponseSender().send("{\"status\": false, \"error\": \"File not found\"}");
				info("SAVE failed (NOT_FOUND) for file " + file);
				break;
			case "compile":
				bid = Optional.ofNullable(exchange.getQueryParameters().get("bid")).map(Deque::getFirst).orElse(null);
				exchange.startBlocking();
				inp = FileUtils.readFile(exchange.getInputStream());
				rc = JsonPath.parse(inp);
				file = rc.read("$.file");
				contents = rc.read("$.contents");
				info("COMPILE requested for file " + file);
				if(file!=null && contents!=null) {
					String err = JsonUiIXtextEditorCallback.compileTemplateFile(contents);
					if(err!=null) {
						exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
						exchange.getResponseSender().send(err);
						info("COMPILE failed for file " + file + " with err " + err);
					} else {
						exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
						exchange.getResponseSender().send("{\"status\": true}");
						info("COMPILE was successful for file " + file);
					}
					return;
				}
				exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
				exchange.getResponseSender().send("{\"status\": false, \"error\": \"Contents not found\"}");
				info("COMPILE failed (NOT_FOUND) for file " + file);
				break;
			case "title":
				bid = Optional.ofNullable(exchange.getQueryParameters().get("bid")).map(Deque::getFirst).orElse(null);
				String clean = Optional.ofNullable(exchange.getQueryParameters().get("clean")).map(Deque::getFirst).orElse("0");
				info("TITLE change requested");
				IWebBrowser wb = JsonUiIHyperlinkDetector.getBrowser(bid);
				makeBrowserDirtyOrClean(wb, clean.equals("0"));
				exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
				exchange.getResponseSender().send("{\"status\": true}");
				info("TITLE change failed");
				break;
			default:
				break;
			}
		}
	}
	
	public static void makeBrowserDirtyOrClean(IWebBrowser wb, boolean dirty) throws Exception {
		if (wb != null) {
			InternalBrowserInstance ibe = (InternalBrowserInstance)wb;
			Field f = InternalBrowserInstance.class.getDeclaredField("part");
			f.setAccessible(true);
			WebBrowserEditor wbe = (WebBrowserEditor)f.get(ibe);
			f = WorkbenchPart.class.getDeclaredField("partSite");
			f.setAccessible(true);
			IWorkbenchPartSite wbes = (IWorkbenchPartSite)f.get(wbe);
			f = PartSite.class.getDeclaredField("model");
			f.setAccessible(true);
			PartImpl part = (PartImpl)f.get(wbes);
			PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
				@Override
				public void run() {
					try {
						part.setDirty(dirty);
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			});
			
		}
	}
	
	static class AceApiPullHandler implements HttpHandler {
		@Override
		public void handleRequest(HttpServerExchange exchange) throws Exception {
			if (exchange.isInIoThread()) {
		      exchange.dispatch(this);
		      return;
		    }
			String action = Optional.ofNullable(exchange.getQueryParameters().get("action")).map(Deque::getFirst).orElse("fetch");
			switch (action) {
			case "fetch":
				exchange.startBlocking();
				String file = FileUtils.readFile(exchange.getInputStream());
				info("FETCH requested for file " + file);
				if(file!=null) {
					try {
						String contents = FileUtils.readFile(new FileInputStream(file));
						exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "text/plain");
						exchange.getResponseSender().send(contents);
						info("FETCH was successful for file " + file);
						return;
					} catch (Exception e) {
						info("FETCH failed (NOT_FOUND) for file " + file);
					}
				}
				exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
				exchange.getResponseSender().send("{\"status\": false, \"error\": \"File not found\"}");
				break;
			case "complete-func":
				String project = Optional.ofNullable(exchange.getQueryParameters().get("project")).map(Deque::getFirst).orElse(null);
				String text = Optional.ofNullable(exchange.getQueryParameters().get("text")).map(Deque::getFirst).orElse(null);
				String text1 = Optional.ofNullable(exchange.getQueryParameters().get("text1")).map(Deque::getFirst).orElse(null);
				FaugjsConfigContext cntxt = JsonUiIXtextEditorCallback.getObj(project);
				exchange.startBlocking();
				String currfile = FileUtils.readFile(exchange.getInputStream());
				currfile = currfile.substring(cntxt.getRootProjectPath().length());
				info("SEARCH_FUNC requested for file " + currfile);
				if(text!=null) {
					Set<String> matched = JsonUiIXtextEditorCallback.matchingFuncsOrGvars(text, text1, 1, currfile);
					StringBuilder sb = new StringBuilder();
					sb.append("[");
					for (String s : matched) {
						sb.append("\"");
						sb.append(s);
						sb.append("\"");
						sb.append(",");
					}
					if(sb.charAt(sb.length()-1)==',') {
						sb.deleteCharAt(sb.length()-1);
					}
					sb.append("]");
					exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
					exchange.getResponseSender().send(sb.toString());
					return;
				}
				exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
				exchange.getResponseSender().send("[]");
				break;
			case "complete-gvar":
				project = Optional.ofNullable(exchange.getQueryParameters().get("project")).map(Deque::getFirst).orElse(null);
				String gvar = Optional.ofNullable(exchange.getQueryParameters().get("text")).map(Deque::getFirst).orElse(null);
				cntxt = JsonUiIXtextEditorCallback.getObj(project);
				exchange.startBlocking();
				currfile = FileUtils.readFile(exchange.getInputStream());
				currfile = currfile.substring(cntxt.getRootProjectPath().length());
				info("SEARCH_VAR requested for file " + currfile);
				if(gvar!=null) {
					Set<String> matched = JsonUiIXtextEditorCallback.matchingFuncsOrGvars(gvar, null, 2, currfile);
					StringBuilder sb = new StringBuilder();
					sb.append("[");
					for (String s : matched) {
						sb.append("\"");
						sb.append(s);
						sb.append("\"");
						sb.append(",");
					}
					if(sb.charAt(sb.length()-1)==',') {
						sb.deleteCharAt(sb.length()-1);
					}
					sb.append("]");
					exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
					exchange.getResponseSender().send(sb.toString());
					return;
				}
				exchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
				exchange.getResponseSender().send("[]");
				break;
			default:
				break;
			}
		}
	}
	
	public static int getAceEditorPort() {
		return INSTANCE.getPreferenceStore().getInt(FaugJsPreferences.ACE_EDITOR_PORT);
	}
	
	public static boolean isValidateJson() {
		return INSTANCE.getPreferenceStore().getBoolean(FaugJsPreferences.VALIDATE_JSON);
	}
	
	public static boolean isValidateJslint() {
		return INSTANCE.getPreferenceStore().getBoolean(FaugJsPreferences.VALIDATE_JSLINT);
	}

	static int aceEditorPort = 0;
	public static String getAceUrl() {
		return "http://localhost:" + aceEditorPort + "/static/index.html";
	}
	
	@Override
	public void start(BundleContext context) throws Exception {
		super.start(context);
		INSTANCE = this;
		
		/*IEclipseContext eclipseContext = EclipseContextFactory.getServiceContext(context);
		IEventBroker eventBroker = eclipseContext.get(IEventBroker.class);
		EventHandler ev = new EventHandler() {
			@Override
			public void handleEvent(Event event) {
				//Object part = event.getProperty(UIEvents.EventTags.ELEMENT);
				//boolean tbr =(Boolean) event.getProperty(UIEvents.EventTags.NEW_VALUE);
			}
		};
		eventBroker.subscribe(UIEvents.UIElement.TOPIC_TOBERENDERED, ev);*/
		
		Bundle bundle = context.getBundle();
		IPath stateLoc = Platform.getStateLocation(bundle);
		File wkFolder = stateLoc.toFile();
		if(new File(wkFolder.getAbsolutePath()+File.separator+"ace").exists()) {
			FileUtils.deleteRecursive(Paths.get(wkFolder.getAbsolutePath()+File.separator+"ace"));
		}
		unzipZipFile(JsActivator.class.getResourceAsStream("/ace.zip"), wkFolder.getAbsolutePath());
		
		aceEditorPort = getAceEditorPort();
		while(true) {
			try {
				Socket s = new Socket("localhost", aceEditorPort);
				s.close();
				Thread.sleep(1000);
				aceEditorPort++;
			} catch (Exception e) {
				break;
			}
		}
		
		//System.out.println(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getEditorReferences().length);
		us = Undertow.builder().addHttpListener(aceEditorPort, "localhost").setHandler(Handlers.path()
				.addPrefixPath("/push", Handlers.routing().post("/{action}", new AceApiPushHandler()))
				.addPrefixPath("/pull", Handlers.routing().post("/{action}", new AceApiPullHandler()))
				.addPrefixPath("/static/", resource(new PathResourceManager(Paths.get(wkFolder.getAbsolutePath()+File.separator+"ace"), 100)).setDirectoryListingEnabled(false)))
				.build();
		server = new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					info("Started ace server");
					us.start();
				} catch (Throwable e) {
					e.printStackTrace();
				}
			}
		});
		server.start();
	}

	@Override
	public void stop(BundleContext context) throws Exception {
		JsonUiIHyperlinkDetector.closeAllBrowsers();
		injectors.clear();
		INSTANCE = null;
		super.stop(context);
		if(us!=null) {
			us.stop();
			server.interrupt();
			System.out.println("Stopped ace server");
		}
	}

	public static JsActivator getInstance() {
		return INSTANCE;
	}

	public Injector getInjector(String language) {
		synchronized (injectors) {
			Injector injector = injectors.get(language);
			if (injector == null) {
				injectors.put(language, injector = createInjector(language));
			}
			return injector;
		}
	}

	protected Injector createInjector(String language) {
		try {
			com.google.inject.Module runtimeModule = getRuntimeModule(language);
			com.google.inject.Module sharedStateModule = getSharedStateModule();
			com.google.inject.Module uiModule = getUiModule(language);
			com.google.inject.Module mergedModule = Modules2.mixin(runtimeModule, sharedStateModule, uiModule);
			return Guice.createInjector(mergedModule);
		} catch (Exception e) {
			error("Failed to create injector for " + language, null);
			error(e.getMessage(), e);
			throw new RuntimeException("Failed to create injector for " + language, e);
		}
	}

	protected com.google.inject.Module getRuntimeModule(String grammar) {
		if (COM_FAUG_MVC_JS_FAUG.equals(grammar)) {
			return new FaugRuntimeModule();
		}
		throw new IllegalArgumentException(grammar);
	}

	protected com.google.inject.Module getUiModule(String grammar) {
		if (COM_FAUG_MVC_JS_FAUG.equals(grammar)) {
			return new FaugUiModule(this);
		}
		throw new IllegalArgumentException(grammar);
	}

	protected com.google.inject.Module getSharedStateModule() {
		return new SharedStateModule();
	}
	
	public static void unzipZipFile(InputStream zipFile, String directoryToExtractTo)
    {
        ZipInputStream in = new ZipInputStream(zipFile);
        try
        {
            File directory = new File(directoryToExtractTo);
            if (!directory.exists())
            {
                directory.mkdirs();
                info("Creating directory for Extraction...");
            }
            ZipEntry entry = in.getNextEntry();
            while (entry != null)
            {
                try
                {
                    File file = new File(directory, entry.getName());
                    if (entry.isDirectory())
                    {
                        file.mkdirs();
                    }
                    else
                    {
                        FileOutputStream out = new FileOutputStream(file);
                        byte[] buffer = new byte[2048];
                        int len;
                        while ((len = in.read(buffer)) > 0)
                        {
                            out.write(buffer, 0, len);
                        }
                        out.close();
                    }
                    in.closeEntry();
                    entry = in.getNextEntry();
                }
                catch (Exception e)
                {
                	e.printStackTrace();
                }
            }
        }
        catch (IOException ioe)
        {
        	ioe.printStackTrace();
            return;
        }
    }
}
